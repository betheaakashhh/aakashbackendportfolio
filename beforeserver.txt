const express = require('express');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const mongoose = require('mongoose');
require('dotenv').config();

const app = express();

// Debug: Check environment variables
console.log('Environment check:');
console.log('MONGODB_URI:', process.env.MONGODB_URI ? 'âœ“ Loaded' : 'âœ— Missing');
console.log('JWT_SECRET:', process.env.JWT_SECRET ? 'âœ“ Loaded' : 'âœ— Missing');
console.log('PORT:', process.env.PORT || 5000);

// Middleware - MUST BE BEFORE ROUTES
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

const allowedOrigins = [
  'http://localhost:3000',
  'http://localhost:5173', 
  'http://localhost:5174',
  process.env.FRONTEND_URL
].filter(Boolean);

// Enhanced CORS configuration
app.use(cors({
  origin: function (origin, callback) {
    if (!origin) return callback(null, true);
    
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      console.log('CORS blocked for origin:', origin);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}));

// Handle preflight requests for all routes
app.use((req, res, next) => {
  if (req.method === 'OPTIONS') {
    res.header('Access-Control-Allow-Origin', req.headers.origin || '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
    res.header('Access-Control-Allow-Credentials', 'true');
    return res.sendStatus(200);
  }
  next();
});

// MongoDB Connection
const connectDB = async () => {
  try {
    const mongoURI = process.env.MONGODB_URI;
    
    if (!mongoURI) {
      throw new Error('MONGODB_URI is not defined in environment variables');
    }

    await mongoose.connect(mongoURI);
    
    console.log('âœ… MongoDB Connected Successfully');
  } catch (error) {
    console.error('âŒ MongoDB Connection Error:', error.message);
    console.log('ðŸ’¡ Tip: Check your .env file and make sure MongoDB is running');
    process.exit(1);
  }
};

// User Schema
const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

const User = mongoose.model('User', userSchema);

// Project Request Schema
const projectRequestSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  projectName: {
    type: String,
    required: true,
    trim: true
  },
  duration: {
    type: String,
    required: true
  },
  budget: {
    type: Number,
    required: true
  },
  tools: {
    type: String,
    required: true
  },
  projectType: {
    type: String,
    required: true
  },
  description: {
    type: String,
    required: true
  },
  attachmentLink: {
    type: String,
    default: ''
  },
  status: {
    type: String,
    enum: ['requested', 'accepted', 'negotiable', 'rejected'],
    default: 'requested'
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

const ProjectRequest = mongoose.model('ProjectRequest', projectRequestSchema);

// JWT Secret
const JWT_SECRET = process.env.JWT_SECRET || 'your-fallback-secret-key-for-development-only-change-in-production';

// Middleware to verify token
const verifyToken = (req, res, next) => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ message: 'No token provided' });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.userId = decoded.userId;
    next();
  } catch (error) {
    console.error('Token verification error:', error);
    return res.status(401).json({ message: 'Invalid token' });
  }
};

// ==================== ROUTES ====================

// Health Check
app.get('/', (req, res) => {
  res.json({ 
    message: 'Portfolio API is running',
    timestamp: new Date().toISOString()
  });
});

// API Health Check
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'OK',
    database: mongoose.connection.readyState === 1 ? 'Connected' : 'Disconnected',
    timestamp: new Date().toISOString()
  });
});

// ==================== AUTH ROUTES ====================

// Signup Route
app.post('/api/auth/signup', async (req, res) => {
  try {
    console.log('Signup request received:', req.body);
    const { name, email, password } = req.body;

    if (!name || !email || !password) {
      return res.status(400).json({ message: 'All fields are required' });
    }

    if (password.length < 6) {
      return res.status(400).json({ message: 'Password must be at least 6 characters' });
    }

    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'Email already registered' });
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    const user = new User({
      name,
      email,
      password: hashedPassword
    });

    await user.save();

    const token = jwt.sign(
      { userId: user._id },
      JWT_SECRET,
      { expiresIn: '7d' }
    );

    res.status(201).json({
      message: 'User created successfully',
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email
      }
    });
  } catch (error) {
    console.error('Signup error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Login Route
app.post('/api/auth/login', async (req, res) => {
  try {
    console.log('Login request received:', req.body);
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ message: 'Email and password are required' });
    }

    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    const token = jwt.sign(
      { userId: user._id },
      JWT_SECRET,
      { expiresIn: '7d' }
    );

    res.json({
      message: 'Login successful',
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Get User Profile
app.get('/api/auth/profile', verifyToken, async (req, res) => {
  try {
    const user = await User.findById(req.userId).select('-password');
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    console.error('Profile error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Verify Token
app.get('/api/auth/verify', verifyToken, (req, res) => {
  res.json({ 
    message: 'Token is valid', 
    userId: req.userId,
    valid: true 
  });
});

// Logout
app.post('/api/auth/logout', (req, res) => {
  res.json({ message: 'Logout successful' });
});

// ==================== PROJECT ROUTES ====================

// Submit New Project Request
app.post('/api/projects/requests', verifyToken, async (req, res) => {
  try {
    console.log('Project request received:', req.body);
    const { projectName, duration, budget, tools, projectType, description, attachmentLink } = req.body;

    if (!projectName || !duration || !budget || !tools || !projectType || !description) {
      return res.status(400).json({ message: 'All required fields must be filled' });
    }

    const projectRequest = new ProjectRequest({
      userId: req.userId,
      projectName,
      duration,
      budget: Number(budget),
      tools,
      projectType,
      description,
      attachmentLink: attachmentLink || '',
      status: 'requested'
    });

    await projectRequest.save();
    console.log(' Project saved:', projectRequest._id);

    res.status(201).json({
      message: 'Project request submitted successfully',
      project: projectRequest
    });
  } catch (error) {
    console.error(' Project request error:', error);
    res.status(500).json({ message: 'Server error: ' + error.message });
  }
});

// Get All Project Requests for Current User
app.get('/api/projects/requests', verifyToken, async (req, res) => {
  try {
    console.log('Fetching projects for user:', req.userId);
    const projects = await ProjectRequest.find({ userId: req.userId })
      .sort({ createdAt: -1 });

    console.log('Found projects:', projects.length);
    res.json(projects);
  } catch (error) {
    console.error(' Get projects error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Get Single Project Request
app.get('/api/projects/requests/:id', verifyToken, async (req, res) => {
  try {
    const project = await ProjectRequest.findOne({
      _id: req.params.id,
      userId: req.userId
    });

    if (!project) {
      return res.status(404).json({ message: 'Project not found' });
    }

    res.json(project);
  } catch (error) {
    console.error('Get project error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Update Project Request Status
app.put('/api/projects/requests/:id/status', verifyToken, async (req, res) => {
  try {
    console.log('ðŸ”„ Updating status for project:', req.params.id);
    const { status } = req.body;

    if (!['requested', 'accepted', 'negotiable', 'rejected'].includes(status)) {
      return res.status(400).json({ message: 'Invalid status' });
    }

    const project = await ProjectRequest.findOneAndUpdate(
      { _id: req.params.id, userId: req.userId },
      { 
        status,
        updatedAt: new Date()
      },
      { new: true }
    );

    if (!project) {
      return res.status(404).json({ message: 'Project not found' });
    }

    console.log('Status updated:', status);
    res.json({
      message: 'Project status updated successfully',
      project
    });
  } catch (error) {
    console.error('Update status error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Update Project Request (Full Update)
app.put('/api/projects/requests/:id', verifyToken, async (req, res) => {
  try {
    const { projectName, duration, budget, tools, projectType, description, attachmentLink } = req.body;

    const project = await ProjectRequest.findOneAndUpdate(
      { _id: req.params.id, userId: req.userId },
      {
        projectName,
        duration,
        budget: Number(budget),
        tools,
        projectType,
        description,
        attachmentLink,
        updatedAt: new Date()
      },
      { new: true }
    );

    if (!project) {
      return res.status(404).json({ message: 'Project not found' });
    }

    res.json({
      message: 'Project updated successfully',
      project
    });
  } catch (error) {
    console.error('Update project error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Delete Project Request
app.delete('/api/projects/requests/:id', verifyToken, async (req, res) => {
  try {
    const project = await ProjectRequest.findOneAndDelete({
      _id: req.params.id,
      userId: req.userId
    });

    if (!project) {
      return res.status(404).json({ message: 'Project not found' });
    }

    res.json({ message: 'Project deleted successfully' });
  } catch (error) {
    console.error('Delete project error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Get All Projects (Admin view)
app.get('/api/projects/all', verifyToken, async (req, res) => {
  try {
    const projects = await ProjectRequest.find()
      .populate('userId', 'name email')
      .sort({ createdAt: -1 });

    res.json(projects);
  } catch (error) {
    console.error('Get all projects error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// 404 Handler for API routes
app.use('/api', (req, res, next) => {
  console.log(' 404 - Route not found:', req.method, req.originalUrl);
  res.status(404).json({ message: 'API endpoint not found' });
});

// Global error handler
app.use((error, req, res, next) => {
  console.error(' Global error handler:', error);
  res.status(500).json({ message: 'Internal server error' });
});

// Start server AFTER connecting to DB
const PORT = process.env.PORT || 5000;

connectDB().then(() => {
  app.listen(PORT, () => {
    console.log('=================================');
    console.log(` Server running on port ${PORT}`);
    console.log(` API Base: http://localhost:${PORT}`);
    console.log(` Health: http://localhost:${PORT}/api/health`);
    console.log('=================================');
    console.log('Available Routes:');
    console.log('  POST   /api/auth/signup');
    console.log('  POST   /api/auth/login');
    console.log('  GET    /api/auth/profile');
    console.log('  GET    /api/auth/verify');
    console.log('  POST   /api/projects/requests');
    console.log('  GET    /api/projects/requests');
    console.log('  GET    /api/projects/requests/:id');
    console.log('  PUT    /api/projects/requests/:id');
    console.log('  PUT    /api/projects/requests/:id/status');
    console.log('  DELETE /api/projects/requests/:id');
    console.log('=================================');
  });
});